#!/usr/bin/env python

"""Check files against a list of commonly misspelled words.

Wikipedia contains a large number of proper nouns and technical
terms. Traditional spell-checking in this case is problematic.
Instead it has a page that people can use to list commonly misspelled
words and to then use that to find misspellings.

A similar approach can be taken to spell-checking (or misspell-checking)
the files in a body of source code.

This tool uses the English wordlist from Wikipedia in order to scan
source code and identify misspelled words.

"""

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import codecs
import io
import optparse
import os
import re
import sys

import misspellings_lib as misspellings


EXCLUDED_RE = re.compile('\.(py[co]|s?o|a)$')
EXCLUDED_DIRS = ('.bzr', '.git', '.hg', '.svn', '.tox', 'CVS')


def get_a_line(filename, lineno):
    """Read a specific line from a file."""
    # Perhaps caching this would be nice, but assuming not an insane
    # number of misspellings.
    return io.open(filename, 'r').readlines()[lineno - 1].rstrip()


class Suggestions(object):

    """Class to query user on which correction should be used."""

    def __init__(self):
        self.last_suggestions = {}

    def get_suggestion(self, filename, lineno, word, suggestions):
        """Show line from file, a misspelled word and request replacement."""
        if word not in self.last_suggestions:
            self.last_suggestions[word] = suggestions[0]
        line = get_a_line(filename, lineno)
        sys.stdout.write('> %s\nReplace "%s" with one of %s\nChoose [%s]:' %
                         (line, word, ','.join(suggestions),
                          self.last_suggestions[word]))
        suggestion = sys.stdin.readline().strip()
        if not suggestion:
            suggestion = self.last_suggestions[word]
        else:
            self.last_suggestions[word] = suggestion
        return suggestion


def print_file_context(fn, target_line_num, context=5):
    """Show a line from a file in context."""
    line_num = 1
    start_line = target_line_num - context
    end_line = target_line_num + context
    with io.open(fn, 'r') as f:
        for line in f:
            if (line_num > start_line) and (line_num < end_line):
                if line_num == target_line_num:
                    sys.stdout.write('+%5d %s' % (line_num, line))
                else:
                    sys.stdout.write(' %5d %s' % (line_num, line))
            line_num += 1


def parse_file_list(filename):
    """Show a line from a file in context."""
    f = sys.stdin
    try:
        if filename != '-':
            f = io.open(filename, 'r')
        return [line.strip() for line in f]
    except IOError:
        raise
    finally:
        if f != sys.stdin:
            f.close()


def esc_sed(raw_text):
    """Escape chars for a sed command on a shell command line."""
    return raw_text.replace('"', '\\"').replace('/', '\\/')


def esc_file(raw_text):
    """Escape chars for a file name on a shell command line."""
    return raw_text.replace('\'', '\'"\'"\'')


# Output routines.
def output_normal(ms, filenames, output):
    """Print a list of misspelled words and their corrections.

    Return True if misspellings are found.

    """
    found = False

    for filename in filenames:
        errors, results = ms.check(filename)
        for res in results:
            output.write(
                '%s:%d: %s -> %s\n' %
                (res[0], res[1], res[2], ','.join(
                    ['"%s"' % w for w in ms.suggestions(res[2])])))
            found = True

        for err in errors:
            sys.stderr.write('ERROR: %s\n' % err)
        output.flush()

    return found


def output_sed_script(ms, parser, opts, filenames):
    """Output a series of portable sed commands to change the file."""
    if os.path.exists(opts.script_output):
        # Emit an error is the file already exists in case the user
        # forgets to give the file - but does give source files.
        parser.error('The sed script file "%s" must not exist.' %
                     opts.script_output)

    sg = Suggestions()

    with io.open(opts.script_output, 'w') as sed_script:
        for filename in filenames:
            errors, results = ms.check(filename)
            for res in results:
                suggestions = ms.suggestions(res[2])
                if len(suggestions) == 1:
                    suggestion = suggestions[0]
                else:
                    suggestion = sg.get_suggestion(
                        res[0], res[1], res[2], suggestions)
                if suggestion != res[2]:
                    sed_script.write(
                        'cp "%(f)s" "%(f)s,"\n'
                        'sed "%(lc)ds/%(wrd)s/%(rep)s/" "%(f)s" > "%(f)s,"\n'
                        'mv "%(f)s," "%(f)s"\n'
                        % {'f': esc_file(res[0]), 'lc': res[1],
                           'wrd': esc_sed(res[2]), 'rep': esc_sed(suggestion)})
            for err in errors:
                sys.stderr.write('ERROR: %s\n' % err)


def expand_directories(path_list):
    """Return list with directories replaced their contained files."""
    for path in path_list:
        if os.path.isdir(path):
            for root, dirnames, filenames in os.walk(path):
                for name in filenames:
                    if not EXCLUDED_RE.search(name):
                        yield os.path.join(root, name)

                for exdir in EXCLUDED_DIRS:
                    if exdir in dirnames:
                        dirnames.remove(exdir)
        else:
            yield path


def main():
    """Entry point."""
    parser = optparse.OptionParser(
        usage='Usage: %prog [-f file_list] [files]',
        description=__doc__.split('\n')[0],
        epilog='  files: Zero or more files to check.',
        version='%prog {0}'.format(misspellings.__version__),
        prog='misspellings')
    parser.add_option('-f', dest='file_list', metavar='file',
                      help='file containing list of files to check')
    parser.add_option('-m', dest='ms_file', metavar='file',
                      help='file containing list of misspelled words &'
                           ' corrections')
    parser.add_option('-d', dest='dump_ms', action='store_true',
                      help='dump the list of misspelled words')
    parser.add_option('-i', dest='interactive', action='store_true',
                      help='interactively fix the file')
    parser.add_option('-s', dest='script_output', metavar='file',
                      help='create a shell script to interactively correct'
                           ' the files - script saved to the given file')
    opts, filenames = parser.parse_args()

    if opts.file_list:
        try:
            filenames += parse_file_list(opts.file_list)
        except IOError as exception:
            parser.error(exception)
            return 1

    output = codecs.getwriter('utf-8')(sys.stdout.buffer
                                       if hasattr(sys.stdout, 'buffer')
                                       else sys.stdout)

    ms = misspellings.Misspellings(misspelling_file=opts.ms_file)
    filenames = expand_directories(filenames)

    if opts.dump_ms:
        for word, correction in ms.dump_misspelling_list():
            output.write('%s %s\n' % (word, correction))
    if not opts.interactive:
        if not opts.script_output:
            return 2 if output_normal(ms,
                                      filenames=filenames,
                                      output=output) else 0
        else:
            output_sed_script(ms, parser, opts, filenames=filenames)
    else:
        print('Interactive mode not implemented yet.',
              file=sys.stderr)

if __name__ == '__main__':
    sys.exit(main())
